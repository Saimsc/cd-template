name: CICD TEMPLATE VER1.2

on:
  workflow_call:
    inputs:
      # control flags (passed as strings "true"/"false")
      build_code:      { type: string, required: true }
      build_docker:    { type: string, required: true }
      codeql:          { type: string, required: true }
      deploy:          { type: string, required: true }

      # build/deploy context
      application_name:{ type: string, required: false, default: "app" }
      image_tag:       { type: string, required: true }
      ecr_repo:        { type: string, required: true }     # e.g. "commitbooking"
      aws_region:      { type: string, required: true }
      aws_role_arn:    { type: string, required: true }     # OIDC role to assume

      # k8s/helm
      eks_cluster:     { type: string, required: true }
      namespace:       { type: string, required: true }
      release_name:    { type: string, required: true }     # helm release
      chart_path:      { type: string, required: true }     # e.g. "helm/commitbooking"

      # values pulled by main workflow from values.json
      replica_count:   { type: string, required: true }
      autoscaling:     { type: string, required: true }      # "true"/"false"
      service_type:    { type: string, required: true }      # e.g. "ClusterIP"|"NodePort"|"LoadBalancer"
      ingress_enabled: { type: string, required: true }      # "true"/"false"

      # CodeQL specifics
      codeql_languages:{ type: string, required: false, default: "java" }  # comma-separated if multiple

permissions:
  contents: read
  id-token: write
  security-events: write   # needed for CodeQL

jobs:
  # Optional: compile/unit test, controlled by build_code
  build:
    if: ${{ inputs.build_code == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Example Java build â€“ adjust for your stack (Maven/Gradle/Node/etc.)
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Build (Maven example)
        run: mvn -B -ntp -DskipTests package

  docker:
    if: ${{ inputs.build_docker == 'true' }}
    needs: [build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws_role_arn }}
          aws-region:     ${{ inputs.aws_region }}

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Docker image
        env:
          ECR_REGISTRY:   ${{ steps.ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ inputs.ecr_repo }}
          IMAGE_TAG:      ${{ inputs.image_tag }}
        run: |
          IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Building $IMAGE"
          docker build -t "$IMAGE" .
          docker push "$IMAGE"
          echo "image_full=$IMAGE" >> $GITHUB_OUTPUT

  codeql-scan:
    if: ${{ inputs.codeql == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ inputs.codeql_languages }}

      # For Java/JS this usually works. For custom builds replace with your build commands.
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{ inputs.codeql_languages }}"

  deploy:
    if: ${{ inputs.deploy == 'true' }}
    needs: [docker]   # ensures we only deploy after image is pushed
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws_role_arn }}
          aws-region:     ${{ inputs.aws_region }}

      - name: Login to Amazon ECR (to get registry URL)
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update kubeconfig for EKS
        run: aws eks update-kubeconfig --name "${{ inputs.eks_cluster }}" --region "${{ inputs.aws_region }}"

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Create Helm override file
        id: overrides
        env:
          ECR_REGISTRY:   ${{ steps.ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ inputs.ecr_repo }}
          IMAGE_TAG:      ${{ inputs.image_tag }}
          REPLICA_COUNT:  ${{ inputs.replica_count }}
          AUTOSCALING:    ${{ inputs.autoscaling }}
          SERVICE_TYPE:   ${{ inputs.service_type }}
          INGRESS:        ${{ inputs.ingress_enabled }}
        run: |
          cat > override-values.yaml <<'YAML'
          replicaCount: ${REPLICA_COUNT}
          autoscaling:
            enabled: ${AUTOSCALING}
          service:
            type: ${SERVICE_TYPE}
          ingress:
            enabled: ${INGRESS}
          image:
            repository: ${ECR_REGISTRY}/${ECR_REPOSITORY}
            tag: ${IMAGE_TAG}
          YAML
          echo "override_file=override-values.yaml" >> $GITHUB_OUTPUT

      - name: Helm upgrade/install
        run: |
          helm upgrade --install "${{ inputs.release_name }}" "${{ inputs.chart_path }}" \
            --namespace "${{ inputs.namespace }}" --create-namespace \
            -f "${{ steps.overrides.outputs.override_file }}"
